/**
 * Registry Generator
 *
 * Generates src/generated/registry.ts from discovered agents
 */

import { join } from 'node:path';
import { writeFileSync, mkdirSync, existsSync, unlinkSync } from 'node:fs';
import { StructuredError } from '@agentuity/core';
import { toCamelCase, toPascalCase } from '../../../utils/string';
import type { AgentMetadata } from './agent-discovery';
import type { RouteInfo } from './route-discovery';

const AgentIdentifierCollisionError = StructuredError('AgentIdentifierCollisionError');

/**
 * Generate src/generated/registry.ts with agent registry and types
 */
export function generateAgentRegistry(srcDir: string, agents: AgentMetadata[]): void {
	const generatedDir = join(srcDir, 'generated');
	const registryPath = join(generatedDir, 'registry.ts');

	// Detect naming collisions in generated identifiers
	const generatedNames = new Set<string>();
	const collisions: string[] = [];

	for (const agent of agents) {
		const camelName = toCamelCase(agent.name);

		if (generatedNames.has(camelName)) {
			collisions.push(`Identifier collision detected: "${camelName}" (from "${agent.name}")`);
		}
		generatedNames.add(camelName);
	}

	if (collisions.length > 0) {
		throw new AgentIdentifierCollisionError({
			message:
				`Agent identifier naming collisions detected:\n${collisions.join('\n')}\n\n` +
				`This occurs when different agent names produce the same camelCase identifier.\n` +
				`Please rename your agents to avoid this collision.`,
		});
	}

	// Generate imports for all agents
	const imports = agents
		.map(({ name, filename }) => {
			const camelName = toCamelCase(name);
			// Handle both './agent/...' and 'src/agent/...' formats
			let relativePath = filename;
			if (relativePath.startsWith('./agent/')) {
				// ./agent/foo.ts -> ../agent/foo.js (use .js extension for TypeScript)
				relativePath = relativePath
					.replace(/^\.\/agent\//, '../agent/')
					.replace(/\.tsx?$/, '.js');
			} else if (relativePath.startsWith('src/agent/')) {
				// src/agent/foo.ts -> ../agent/foo.js (use .js extension for TypeScript)
				relativePath = relativePath
					.replace(/^src\/agent\//, '../agent/')
					.replace(/\.tsx?$/, '.js');
			}
			return `import ${camelName} from '${relativePath}';`;
		})
		.join('\n');

	// Generate schema type exports for all agents
	const schemaTypeExports = agents
		.map(({ name, description }) => {
			const camelName = toCamelCase(name);
			const pascalName = toPascalCase(name);
			const descComment = description ? `\n * ${description}` : '';

			const parts = [
				'',
				`/**`,
				` * Input type for ${name} agent${descComment}`,
				` */`,
				`export type ${pascalName}Input = InferInput<typeof ${camelName}['inputSchema']>;`,
				'',
				`/**`,
				` * Output type for ${name} agent${descComment}`,
				` */`,
				`export type ${pascalName}Output = InferOutput<typeof ${camelName}['outputSchema']>;`,
				'',
				`/**`,
				` * Input schema type for ${name} agent${descComment}`,
				` */`,
				`export type ${pascalName}InputSchema = typeof ${camelName}['inputSchema'];`,
				'',
				`/**`,
				` * Output schema type for ${name} agent${descComment}`,
				` */`,
				`export type ${pascalName}OutputSchema = typeof ${camelName}['outputSchema'];`,
				'',
				`/**`,
				` * Agent type for ${name}${descComment}`,
				` */`,
				`export type ${pascalName}Agent = AgentRunner<`,
				`\t${pascalName}InputSchema,`,
				`\t${pascalName}OutputSchema,`,
				`\ttypeof ${camelName}['stream'] extends true ? true : false`,
				`>;`,
			];
			return parts.join('\n');
		})
		.join('\n');

	// Generate flat registry structure with JSDoc
	const registry = agents
		.map(({ name, description }) => {
			const camelName = toCamelCase(name);
			const pascalName = toPascalCase(name);
			const descComment = description ? `\n\t * ${description}` : '';

			return `\t/**
	\t * ${name}${descComment}
	\t * @type {${pascalName}Agent}
	\t */
	\t${camelName}: ${camelName},`;
		})
		.join('\n');

	// Generate flat agent type definitions for AgentRegistry interface augmentation
	// Uses the exported Agent types defined above
	const runtimeAgentTypes = agents
		.map(({ name }) => {
			const camelName = toCamelCase(name);
			const pascalName = toPascalCase(name);
			return `		${camelName}: ${pascalName}Agent;`;
		})
		.join('\n');

	const generatedContent = `// @generated
// Auto-generated by Agentuity - DO NOT EDIT
${imports}
import type { AgentRunner } from '@agentuity/runtime';
import type { InferInput, InferOutput } from '@agentuity/core';

// ============================================================================
// Schema Type Exports
// ============================================================================
${schemaTypeExports}

// ============================================================================
// Agent Definitions
// ============================================================================

/**
 * Agent Definitions
 * 
 * Registry of all agents in this application.
 * Provides strongly-typed access to agent metadata and runner functions.
 * 
 * @remarks
 * This object is auto-generated from your agent files during build.
 * Each agent has corresponding Input, Output, and Runner types exported above.
 * 
 * @example
 * \`\`\`typescript
 * import { AgentDefinitions, SessionBasicInput } from './generated/registry';
 * 
 * // Access agent definition
 * const agent = AgentDefinitions.sessionBasic;
 * 
 * // Use typed schema types
 * const input: SessionBasicInput = { ... };
 * const result = await agent.run(input);
 * \`\`\`
 */
export const AgentDefinitions = {
${registry}
} as const;

// ============================================================================
// Module Augmentation
// ============================================================================

// Augment @agentuity/runtime types with strongly-typed agents from this project
declare module "@agentuity/runtime" {
	// Augment the AgentRegistry interface with project-specific strongly-typed agents
	export interface AgentRegistry {
${runtimeAgentTypes}
	}
}

// FOUND AN ERROR IN THIS FILE?
// Please file an issue at https://github.com/agentuity/sdk/issues
// or if you know the fix please submit a PR!
`;

	const agentsDir = join(srcDir, 'agent');
	const legacyTypesPath = join(agentsDir, 'types.generated.d.ts');

	// Ensure src/generated directory exists
	if (!existsSync(generatedDir)) {
		mkdirSync(generatedDir, { recursive: true });
	}

	// Collapse 2+ consecutive empty lines into 1 empty line (3+ \n becomes 2 \n)
	const cleanedContent = generatedContent.replace(/\n{3,}/g, '\n\n');

	writeFileSync(registryPath, cleanedContent, 'utf-8');

	// Remove legacy types.generated.d.ts if it exists (legacy cleanup)
	if (existsSync(legacyTypesPath)) {
		unlinkSync(legacyTypesPath);
	}
}

/**
 * Generate RouteRegistry type definitions from discovered routes.
 *
 * Creates a module augmentation for @agentuity/react that provides
 * strongly-typed route keys with input/output schema information.
 */
export function generateRouteRegistry(srcDir: string, routes: RouteInfo[]): void {
	// Filter routes by type
	const apiRoutes = routes.filter((r) => r.routeType === 'api' || r.routeType === 'stream');
	const websocketRoutes = routes.filter((r) => r.routeType === 'websocket');
	const sseRoutes = routes.filter((r) => r.routeType === 'sse');

	if (apiRoutes.length === 0 && websocketRoutes.length === 0 && sseRoutes.length === 0) {
		return;
	}

	// Generate imports for agents and schemas
	const imports: string[] = [];
	const agentImports = new Map<string, string>();
	const routeFileImports = new Map<string, Set<string>>();

	const allRoutes = [...apiRoutes, ...websocketRoutes, ...sseRoutes];

	// Collect agent imports
	allRoutes.forEach((route) => {
		if (!route.hasValidator) return;

		if (route.agentVariable && route.agentImportPath && !agentImports.has(route.agentVariable)) {
			let resolvedPath = route.agentImportPath;

			if (resolvedPath.startsWith('@agents/') || resolvedPath.startsWith('@agent/')) {
				// Handle both @agents/ and @agent/ aliases -> ../agent/
				const suffix = resolvedPath.startsWith('@agents/')
					? resolvedPath.substring('@agents/'.length)
					: resolvedPath.substring('@agent/'.length);

				// Convert @agent/hello -> ../agent/hello/index.js
				// Convert @agent/hello/agent -> ../agent/hello/agent.js
				if (!suffix.includes('/')) {
					// Bare module (e.g., @agent/hello) - add /index.js
					resolvedPath = `../agent/${suffix}/index.js`;
				} else {
					// File path (e.g., @agent/hello/agent) - add .js
					const finalPath = suffix.endsWith('.js')
						? suffix
						: suffix.replace(/\.tsx?$/, '') + '.js';
					resolvedPath = `../agent/${finalPath}`;
				}
			} else if (resolvedPath.startsWith('@api/')) {
				// src/generated/ -> src/api/ is ../api/
				const suffix = resolvedPath.substring('@api/'.length);
				const finalPath = suffix.endsWith('.js')
					? suffix
					: suffix.replace(/\.tsx?$/, '') + '.js';
				resolvedPath = `../api/${finalPath}`;
			} else if (resolvedPath.startsWith('./') || resolvedPath.startsWith('../')) {
				const routeDir = route.filename.substring(0, route.filename.lastIndexOf('/'));
				resolvedPath = `../${routeDir}/${resolvedPath}`;
				// Add .js extension if not already present
				if (!resolvedPath.endsWith('.js')) {
					resolvedPath = resolvedPath.replace(/\.tsx?$/, '') + '.js';
				}
			}

			const uniqueImportName = route.agentVariable;
			imports.push(`import type ${uniqueImportName} from '${resolvedPath}';`);
			agentImports.set(route.agentVariable, uniqueImportName);
		}

		// Collect schema variable imports
		if (route.inputSchemaVariable || route.outputSchemaVariable) {
			const filename = route.filename.replace(/\\/g, '/');
			const importPath = `../${filename.replace(/\.ts$/, '')}`;

			if (!routeFileImports.has(importPath)) {
				routeFileImports.set(importPath, new Set());
			}

			if (route.inputSchemaVariable) {
				routeFileImports.get(importPath)!.add(route.inputSchemaVariable);
			}
			if (route.outputSchemaVariable) {
				routeFileImports.get(importPath)!.add(route.outputSchemaVariable);
			}
		}
	});

	// Generate schema imports
	routeFileImports.forEach((schemas, importPath) => {
		const schemaList = Array.from(schemas).join(', ');
		imports.push(`import type { ${schemaList} } from '${importPath}';`);
	});

	const importsStr = imports.length > 0 ? imports.join('\n') + '\n' : '';

	// Add InferInput/InferOutput imports if we have any routes with validators
	const hasValidators = allRoutes.some((r) => r.hasValidator);
	const typeImports = hasValidators
		? `import type { InferInput, InferOutput } from '@agentuity/core';\n`
		: '';

	// Generate individual route schema types
	const routeSchemaTypes = allRoutes
		.filter((r) => r.hasValidator)
		.map((route) => {
			const routeKey = route.method ? `${route.method.toUpperCase()} ${route.path}` : route.path;
			const safeName = routeKey
				.replace(/[^a-zA-Z0-9]/g, '_')
				.replace(/^_+|_+$/g, '')
				.replace(/_+/g, '_');
			const pascalName = toPascalCase(safeName);

			let inputType = 'never';
			let outputType = 'never';
			let inputSchemaType = 'never';
			let outputSchemaType = 'never';

			if (route.agentVariable) {
				const importName = agentImports.get(route.agentVariable)!;
				inputType = `InferInput<typeof ${importName}['inputSchema']>`;
				outputType = `InferOutput<typeof ${importName}['outputSchema']>`;
				inputSchemaType = `typeof ${importName} extends { inputSchema?: infer I } ? I : never`;
				outputSchemaType = `typeof ${importName} extends { outputSchema?: infer O } ? O : never`;
			} else if (route.inputSchemaVariable || route.outputSchemaVariable) {
				inputType = route.inputSchemaVariable
					? `InferInput<typeof ${route.inputSchemaVariable}>`
					: 'never';
				outputType = route.outputSchemaVariable
					? `InferOutput<typeof ${route.outputSchemaVariable}>`
					: 'never';
				inputSchemaType = route.inputSchemaVariable
					? `typeof ${route.inputSchemaVariable}`
					: 'never';
				outputSchemaType = route.outputSchemaVariable
					? `typeof ${route.outputSchemaVariable}`
					: 'never';
			}

			if (inputType === 'never' && outputType === 'never') {
				return ''; // Skip routes without schemas
			}

			const parts = [
				'',
				`/**`,
				` * Input type for route: ${routeKey}`,
				` */`,
				`export type ${pascalName}Input = ${inputType};`,
				'',
				`/**`,
				` * Output type for route: ${routeKey}`,
				` */`,
				`export type ${pascalName}Output = ${outputType};`,
				'',
				`/**`,
				` * Input schema type for route: ${routeKey}`,
				` */`,
				`export type ${pascalName}InputSchema = ${inputSchemaType};`,
				'',
				`/**`,
				` * Output schema type for route: ${routeKey}`,
				` */`,
				`export type ${pascalName}OutputSchema = ${outputSchemaType};`,
			];
			return parts.join('\n');
		})
		.filter(Boolean)
		.join('\n');

	// Helper to generate route entry - uses exported schema types
	const generateRouteEntry = (route: RouteInfo): string => {
		const routeKey = route.path;
		const safeName = routeKey
			.replace(/[^a-zA-Z0-9]/g, '_')
			.replace(/^_+|_+$/g, '')
			.replace(/_+/g, '_');
		const pascalName = toPascalCase(safeName);

		if (!route.hasValidator) {
			const streamValue = route.stream === true ? 'true' : 'false';
			return `\t'${routeKey}': {
\t\tinputSchema: never;
\t\toutputSchema: never;
\t\tstream: ${streamValue};
\t};`;
		}

		// Use the exported schema types we generated above
		const importName = route.agentVariable ? agentImports.get(route.agentVariable)! : null;
		const streamValue = importName
			? `typeof ${importName} extends { stream?: infer S } ? S : false`
			: route.stream === true
				? 'true'
				: 'false';

		return `\t'${routeKey}': {
\t\tinputSchema: ${pascalName}InputSchema;
\t\toutputSchema: ${pascalName}OutputSchema;
\t\tstream: ${streamValue};
\t};`;
	};

	// Generate route entries with METHOD prefix for API routes
	const apiRouteEntries = apiRoutes
		.map((route) => {
			const routeKey = `${route.method.toUpperCase()} ${route.path}`;
			return generateRouteEntry({ ...route, path: routeKey });
		})
		.join('\n');

	const websocketRouteEntries = websocketRoutes.map(generateRouteEntry).join('\n');
	const sseRouteEntries = sseRoutes.map(generateRouteEntry).join('\n');

	const generatedContent = `// @generated
// Auto-generated by Agentuity - DO NOT EDIT
${importsStr}${typeImports}
// ============================================================================
// Route Schema Type Exports
// ============================================================================
${routeSchemaTypes}

// ============================================================================
// Route Definitions
// ============================================================================

/**
 * Route Definitions
 * 
 * Type-safe route registry for all API routes, WebSocket connections, and SSE endpoints.
 * Used by @agentuity/react for client-side type-safe routing.
 * 
 * @remarks
 * This module augmentation is auto-generated from your route files during build.
 * Individual route Input/Output types are exported above for direct usage.
 */
declare module '@agentuity/react' {
\t/**
\t * API Route Registry
\t * 
\t * Maps route keys (METHOD /path) to their input/output schemas
\t */
\texport interface RouteRegistry {
${apiRouteEntries}
\t}
\t
\t/**
\t * WebSocket Route Registry
\t * 
\t * Maps WebSocket route paths to their schemas
\t */
\texport interface WebSocketRouteRegistry {
${websocketRouteEntries}
\t}
\t
\t/**
\t * Server-Sent Events Route Registry
\t * 
\t * Maps SSE route paths to their schemas
\t */
\texport interface SSERouteRegistry {
${sseRouteEntries}
\t}
}

// FOUND AN ERROR IN THIS FILE?
// Please file an issue at https://github.com/agentuity/sdk/issues
// or if you know the fix please submit a PR!
`;

	const generatedDir = join(srcDir, 'generated');
	const registryPath = join(generatedDir, 'routes.ts');

	if (!existsSync(generatedDir)) {
		mkdirSync(generatedDir, { recursive: true });
	}

	// Collapse 2+ consecutive empty lines into 1 empty line (3+ \n becomes 2 \n)
	const cleanedContent = generatedContent.replace(/\n{3,}/g, '\n\n');

	writeFileSync(registryPath, cleanedContent, 'utf-8');
}
