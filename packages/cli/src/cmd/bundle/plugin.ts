import type { BunPlugin } from 'bun';
import { dirname, basename, join } from 'node:path';
import { existsSync, writeFileSync } from 'node:fs';
import { parseAgentMetadata } from './ast';
import { applyPatch, generatePatches } from './patch';

function toCamelCase(str: string): string {
	return str
		.replace(/[-_\s]+(.)?/g, (_, char) => (char ? char.toUpperCase() : ''))
		.replace(/^(.)/, (char) => char.toLowerCase());
}

function toPascalCase(str: string): string {
	const camel = toCamelCase(str);
	return camel.charAt(0).toUpperCase() + camel.slice(1);
}

function generateAgentRegistry(srcDir: string, agentInfo: Array<Record<string, string>>) {
	const imports = agentInfo
		.map(({ name, path }) => {
			const camelName = toCamelCase(name);
			const relativePath = path.replace(/^\.\/agents\//, './');
			return `import ${camelName}Agent from '${relativePath}';`;
		})
		.join('\n');

	const registry = agentInfo
		.map(({ name }) => {
			const camelName = toCamelCase(name);
			return `  ${camelName}: ${camelName}Agent,`;
		})
		.join('\n');

	const typeExports = agentInfo
		.map(({ name }) => {
			const camelName = toCamelCase(name);
			const pascalName = toPascalCase(name);
			return `export type ${pascalName}AgentRunner = AgentRunner<typeof ${camelName}Agent['inputSchema'], typeof ${camelName}Agent['outputSchema'], typeof ${camelName}Agent['stream'] extends true ? true : false>;`;
		})
		.join('\n');

	const generatedContent = `// Auto-generated by Agentuity - do not edit manually
${imports}
import type { AgentRunner, Logger } from '@agentuity/runtime';
import type { KeyValueStorage, ObjectStorage, StreamStorage, VectorStorage } from '@agentuity/core';

export const agentRegistry = {
${registry}
} as const;

export type AgentName = keyof typeof agentRegistry;
export type AgentRegistry = typeof agentRegistry;

// Typed runners for each agent
${typeExports}

// Augment Context to provide strongly-typed agents
declare module "hono" {
	interface Context {
	   agentName: AgentName;
	   agent: {
	     [K in AgentName]: AgentRunner<AgentRegistry[K]['inputSchema'], AgentRegistry[K]['outputSchema'], AgentRegistry[K]['stream'] extends true ? true : false>;
	   };
	   waitUntil: (promise: Promise<void> | (() => void | Promise<void>)) => void;
	   logger: Logger;
	   kv: KeyValueStorage;
	   objectstore: ObjectStorage;
	   stream: StreamStorage;
	   vector: VectorStorage;
  }
}
`;

	const agentsDir = join(srcDir, 'agents');
	const registryPath = join(agentsDir, 'registry.generated.ts');

	writeFileSync(registryPath, generatedContent, 'utf-8');

	const clientTypesContent = `// Auto-generated by Agentuity - do not edit manually
// This file augments @agentuity/react with your project's agent types
${agentInfo
	.map(({ name, path }) => {
		const camelName = toCamelCase(name);
		const relativePath = path.replace(/^\.\/agents\//, './');
		return `import type ${camelName}Agent from '${relativePath}';`;
	})
	.join('\n')}
import type { Agent } from '@agentuity/react';

declare module '@agentuity/react' {
	interface AgentRegistry {
${agentInfo
	.map(({ name }) => {
		const camelName = toCamelCase(name);
		return `		'${name}': Agent<typeof ${camelName}Agent['inputSchema'], typeof ${camelName}Agent['outputSchema']>;`;
	})
	.join('\n')}
	}
}
`;

	const clientTypesPath = join(agentsDir, 'types.generated.d.ts');
	writeFileSync(clientTypesPath, clientTypesContent, 'utf-8');
}

const AgentuityBundler: BunPlugin = {
	name: 'Agentuity Bundler',
	setup(build) {
		const rootDir = build.config.root ?? '.';
		const srcDir = join(rootDir, 'src');
		const routes: Set<string> = new Set();
		const agentInfo: Array<Record<string, string>> = [];
		const agentMetadata: Map<string, Map<string, string>> = new Map<
			string,
			Map<string, string>
		>();
		const transpiler = new Bun.Transpiler({ loader: 'ts' });

		build.onResolve({ filter: /\/route\.ts$/, namespace: 'file' }, async (args) => {
			if (args.path.startsWith(srcDir)) {
				const importPath = args.path
					.replace(rootDir, '')
					.replace('.ts', '')
					.replace('/src/', './');
				routes.add(importPath);
			}
			return args;
		});

		build.onLoad({ filter: /\/agent\.ts$/, namespace: 'file' }, async (args) => {
			let newsource = await Bun.file(args.path).text();
			if (args.path.startsWith(srcDir)) {
				const contents = transpiler.transformSync(newsource);
				const [ns, md] = parseAgentMetadata(rootDir, args.path, contents);
				newsource = ns;
				agentMetadata.set(md.get('identifier')!, md);
			}
			return {
				contents: newsource,
				loader: 'ts',
			};
		});

		const patches = generatePatches();
		for (const [, patch] of patches) {
			let modulePath = join('node_modules', patch.module, '.*');
			if (patch.filename) {
				modulePath = join('node_modules', patch.module, patch.filename + '.*');
			}
			build.onLoad(
				{
					filter: new RegExp(modulePath),
					namespace: 'file',
				},
				async (args) => {
					if (build.config.target !== 'bun') {
						return;
					}
					const [contents, loader] = await applyPatch(args.path, patch);
					return {
						contents,
						loader,
					};
				}
			);
		}

		build.onLoad(
			{
				filter: new RegExp(join(rootDir, 'app.ts')),
				namespace: 'file',
			},
			async (args) => {
				if (build.config.target !== 'bun') {
					return;
				}
				await args.defer();

				const inserts: string[] = [];

				for (const route of routes) {
					const name = basename(dirname(route));
					const agent = route.replace(/\/route$/, '/agent');
					const hasAgent = existsSync(join(srcDir, agent + '.ts'));
					const agentPath = route
						.replace(/\/route$/, '/*')
						.replace('/agents', '/agent')
						.replace('./', '/');
					const routePath = route
						.replace(/\/route$/, '')
						.replace('/apis/', '/api/')
						.replace('/apis', '/api')
						.replace('/agents', '/agent')
						.replace('/agents', '/agent')
						.replace('./', '/');

					let agentDetail: Record<string, string> = {};

					if (hasAgent) {
						const md = agentMetadata.get(name);
						if (!md) {
							throw new Error(`Couldn't find agent metadata for ${route}`);
						}
						agentDetail = {
							name,
							path: `.${agent}`,
							filename: md.get('filename')!,
							identifier: md.get('identifier')!,
							description: md.get('description') ?? '',
						};
						agentInfo.push(agentDetail);
					}

					let buffer = `await (async() => {
    const { createAgentMiddleware, getApp, registerAgent } = await import('@agentuity/runtime');
    const app = getApp()!;
    const route = require('./src/${route}').default;`;
					if (hasAgent) {
						buffer += `
    const agent = require('./src/${agent}').default;
    app.all("${agentPath}", createAgentMiddleware('${name}'));
    registerAgent("${name}", agent);`;
					}
					buffer += `
    app.route("${routePath}", route);
})();`;
					inserts.push(buffer);
				}

				const indexFile = join(srcDir, 'web', 'index.html');

				if (existsSync(indexFile)) {
					inserts.unshift(`await (async () => {
    const { serveStatic } = require('hono/bun');
    const { getApp } = await import('@agentuity/runtime');
    const app = getApp()!;
	const index = await Bun.file(import.meta.dir + '/web/index.js').text();
	const webstatic = serveStatic({ root: import.meta.dir + '/web' });
	app.get('/', (c) => c.html(index));
    app.get('/chunk/*', webstatic);
    app.get('/asset/*', webstatic);
	app.get('/public/*', webstatic);
})();`);
				}

				generateAgentRegistry(srcDir, agentInfo);

				const file = Bun.file(args.path);
				let contents = await file.text();
				let inserted = false;
				const index = contents.indexOf(' createApp(');
				if (index > 0) {
					const endSemi = contents.indexOf(');', index);
					if (endSemi > 0) {
						contents =
							contents.slice(0, endSemi + 2) +
							'\n\n' +
							inserts.join('\n') +
							contents.slice(endSemi + 2);
						inserted = true;
					}
				}
				if (!inserted) {
					contents += `\n${inserts.join('\n')}`;
				}

				return {
					contents,
					loader: 'ts',
				};
			}
		);
	},
};

export default AgentuityBundler;
