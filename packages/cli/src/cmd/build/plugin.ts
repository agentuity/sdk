import type { BunPlugin } from 'bun';
import { dirname, join, resolve } from 'node:path';
import { existsSync, writeFileSync, mkdirSync, unlinkSync } from 'node:fs';
import type { BuildMetadata } from '@agentuity/server';
import {
	parseAgentMetadata,
	parseEvalMetadata,
	parseRoute,
	analyzeWorkbench,
	generateLifecycleTypes,
	findCreateAppEndPosition,
} from './ast';
import { StructuredError, type WorkbenchConfig } from '@agentuity/core';
import { applyPatch, generatePatches } from './patch';
import { createLogger } from '@agentuity/server';
import type { LogLevel } from '../../types';
import { toCamelCase, toPascalCase } from '../../utils/string';
import { generateRouteRegistry, type RouteInfo } from './route-registry';
import { discoverRouteFiles } from './route-discovery';

/**
 * Setup lifecycle types by analyzing app.ts for setup() function
 */
async function setupLifecycleTypes(
	rootDir: string,
	outDir: string,
	srcDir: string,
	logger: ReturnType<typeof createLogger>
): Promise<boolean> {
	// Look for app.ts in both root and src directories
	const rootAppFile = join(dirname(srcDir), 'app.ts');
	const srcAppFile = join(srcDir, 'app.ts');

	let appFile = '';
	if (await Bun.file(rootAppFile).exists()) {
		appFile = rootAppFile;
	} else if (await Bun.file(srcAppFile).exists()) {
		appFile = srcAppFile;
	}

	if (!appFile || !(await Bun.file(appFile).exists())) {
		return false;
	}

	try {
		return await generateLifecycleTypes(rootDir, outDir, appFile);
	} catch (error) {
		logger.fatal('Failed to generate lifecycle types:', error);
	}
}

/**
 * Setup workbench configuration by analyzing app.ts file
 */
async function setupWorkbench(srcDir: string): Promise<WorkbenchConfig | null> {
	// Look for app.ts in both root and src directories
	const rootAppFile = join(dirname(srcDir), 'app.ts');
	const srcAppFile = join(srcDir, 'app.ts');

	let appFile = '';
	if (await Bun.file(rootAppFile).exists()) {
		appFile = rootAppFile;
	} else if (await Bun.file(srcAppFile).exists()) {
		appFile = srcAppFile;
	}

	if (!appFile || !(await Bun.file(appFile).exists())) {
		return null;
	}

	const appContent = await Bun.file(appFile).text();
	const analysis = analyzeWorkbench(appContent);

	if (!analysis.hasWorkbench) {
		return null;
	}

	const workbenchConfig = analysis.config;

	return workbenchConfig;
}

const AgentIdentifierCollisionError = StructuredError('AgentIdentifierCollisionError');

function generateAgentRegistry(srcDir: string, agentInfo: Array<Record<string, string>>) {
	// Detect naming collisions in generated identifiers
	const generatedNames = new Set<string>();
	const collisions: string[] = [];

	for (const agent of agentInfo) {
		const camelName = toCamelCase(agent.name);

		if (generatedNames.has(camelName)) {
			collisions.push(`Identifier collision detected: "${camelName}" (from "${agent.name}")`);
		}
		generatedNames.add(camelName);
	}

	if (collisions.length > 0) {
		throw new AgentIdentifierCollisionError({
			message:
				`Agent identifier naming collisions detected:\n${collisions.join('\n')}\n\n` +
				`This occurs when different agent names produce the same camelCase identifier.\n` +
				`Please rename your agents to avoid this collision.`,
		});
	}

	// Generate imports for all agents
	// Registry is now in .agentuity/, so imports need to go up one level and into src/
	const imports = agentInfo
		.map(({ name, path }) => {
			const camelName = toCamelCase(name);
			const relativePath = path.replace(/^\.\/agent\//, '../src/agent/');
			return `import ${camelName}Agent from '${relativePath}';`;
		})
		.join('\n');

	// Generate flat registry structure (no subagents)
	const registry = agentInfo
		.map(({ name }) => {
			const camelName = toCamelCase(name);
			return `  ${camelName}: ${camelName}Agent,`;
		})
		.join('\n');

	// Generate type exports for all agents
	const typeExports = agentInfo
		.map(({ name }) => {
			const camelName = toCamelCase(name);
			const pascalName = toPascalCase(name);
			return `export type ${pascalName}AgentRunner = AgentRunner<typeof ${camelName}Agent['inputSchema'], typeof ${camelName}Agent['outputSchema'], typeof ${camelName}Agent['stream'] extends true ? true : false>;`;
		})
		.join('\n');

	// Generate flat agent type definitions for AgentRegistry interface augmentation
	const runtimeAgentTypes = agentInfo
		.map(({ name }) => {
			const camelName = toCamelCase(name);
			return `		${camelName}: AgentRunner<typeof ${camelName}Agent['inputSchema'], typeof ${camelName}Agent['outputSchema'], typeof ${camelName}Agent['stream'] extends true ? true : false>;`;
		})
		.join('\n');

	const generatedContent = `/// <reference types="hono" />
// Auto-generated by Agentuity - do not edit manually
${imports}
import type { AgentRunner, Logger } from '@agentuity/runtime';
import type { KeyValueStorage, StreamStorage, VectorStorage } from '@agentuity/core';

/**
 * Registry of all agents in this application.
 * Provides strongly-typed access to agent metadata and runner functions.
 * Auto-generated from your agent files during build.
 */
export const agentRegistry = {
${registry}
} as const;

// Local type aliases for Hono augmentation
type LocalAgentName = keyof typeof agentRegistry;
type LocalAgentRegistry = typeof agentRegistry;

// Typed runners for each agent
${typeExports}

// Augment @agentuity/runtime types with strongly-typed agents from this project
declare module "@agentuity/runtime" {
	// Augment the AgentRegistry interface with project-specific strongly-typed agents
	export interface AgentRegistry {
${runtimeAgentTypes}
	}
}

// NOTE: Hono Context properties are accessed via c.var (e.g., c.var.logger, c.var.kv)
// The Variables interface in @agentuity/runtime defines all available context properties
`;

	const projectRoot = join(srcDir, '..');
	const agentuityDir = join(projectRoot, '.agentuity');
	const registryPath = join(agentuityDir, 'registry.generated.ts');

	const agentsDir = join(srcDir, 'agent');
	const legacyTypesPath = join(agentsDir, 'types.generated.d.ts');

	// Ensure .agentuity directory exists
	if (!existsSync(agentuityDir)) {
		mkdirSync(agentuityDir, { recursive: true });
	}

	writeFileSync(registryPath, generatedContent, 'utf-8');

	// Remove legacy types.generated.d.ts if it exists (now consolidated into registry.generated.ts)
	if (existsSync(legacyTypesPath)) {
		unlinkSync(legacyTypesPath);
	}
}

let metadata: Partial<BuildMetadata>;

export function getBuildMetadata(): Partial<BuildMetadata> {
	return metadata;
}

const AgentNameDuplicateError = StructuredError('AgentNameDuplicateError');
const MetadataPropertyMissingError = StructuredError('MetadataPropertyMissingError')<{
	name: string;
}>();

const AgentuityBundler: BunPlugin = {
	name: 'Agentuity Bundler',
	setup(build) {
		const rootDir = resolve(build.config.root ?? '.');
		const srcDir = join(rootDir, 'src');
		const outDir = build.config.outdir;
		if (!outDir) {
			throw new Error('missing outdir must be set');
		}
		const projectId = build.config.define?.['process.env.AGENTUITY_CLOUD_PROJECT_ID']
			? JSON.parse(build.config.define['process.env.AGENTUITY_CLOUD_PROJECT_ID'])
			: '';
		const deploymentId = build.config.define?.['process.env.AGENTUITY_CLOUD_DEPLOYMENT_ID']
			? JSON.parse(build.config.define['process.env.AGENTUITY_CLOUD_DEPLOYMENT_ID'])
			: '';
		const isDevMode =
			(build.config.define?.['process.env.NODE_ENV']
				? JSON.parse(build.config.define['process.env.NODE_ENV'])
				: 'production') === 'development';
		const agentInfo: Array<Record<string, string>> = [];
		const agentMetadata: Map<string, Map<string, string>> = new Map<
			string,
			Map<string, string>
		>();
		const transpiler = new Bun.Transpiler({ loader: 'ts', target: 'bun' });

		// Scan ALL .ts files in src/agent directory for agents
		build.onLoad({ filter: /\/agent\/.*\.ts$/, namespace: 'file' }, async (args) => {
			let newsource = await Bun.file(args.path).text();
			if (args.path.startsWith(srcDir)) {
				const contents = transpiler.transformSync(newsource);

				// Check if this is an eval file (eval.ts)
				if (args.path.endsWith('/eval.ts')) {
					// parseEvalMetadata will find the agent from the import statement
					const [ns] = await parseEvalMetadata(
						rootDir,
						args.path,
						contents,
						projectId,
						deploymentId,
						undefined, // No agentId - will be resolved from import
						agentMetadata
					);
					newsource = ns;
				} else {
					// Handle regular agent files
					const result = await parseAgentMetadata(
						rootDir,
						args.path,
						contents,
						projectId,
						deploymentId
					);

					// Skip files that don't have a createAgent export
					if (result === undefined) {
						return {
							contents: newsource,
							loader: 'ts',
						};
					}

					const [ns, md] = result;
					newsource = ns;

					// Only process files that actually export an agent
					if (md.has('name')) {
						const newAgentName = md.get('name');
						for (const [, kv] of agentMetadata) {
							const found = kv.get('name');
							if (newAgentName === found) {
								throw new AgentNameDuplicateError({
									message: `The agent in ${kv.get('filename')} and the agent in ${md.get('filename')} have the same name (${found}). Agent Names must be unique within a project.`,
								});
							}
						}

						agentMetadata.set(md.get('name')!, md);
					}
				}
			}
			return {
				contents: newsource,
				loader: 'ts',
			};
		});

		const patches = generatePatches();
		for (const [, patch] of patches) {
			let modulePath = join('node_modules', patch.module, '.*');
			if (patch.filename) {
				modulePath = join('node_modules', patch.module, patch.filename + '.*');
			}
			build.onLoad(
				{
					filter: new RegExp(modulePath),
					namespace: 'file',
				},
				async (args) => {
					if (build.config.target !== 'bun') {
						return;
					}
					const [contents, loader] = await applyPatch(args.path, patch);
					return {
						contents,
						loader,
					};
				}
			);
		}

		build.onLoad(
			{
				filter: new RegExp(join(rootDir, 'app.ts')),
				namespace: 'file',
			},
			async (args) => {
				const logger = createLogger((process.env.AGENTUITY_LOG_LEVEL as LogLevel) || 'info');
				if (build.config.target !== 'bun') {
					return;
				}
				await args.defer();

				const inserts: string[] = [];

				const indexFile = join(srcDir, 'web', 'index.html');

				// Setup workbench configuration - evaluate fresh each time during builds
				const workbenchConfig = await setupWorkbench(srcDir);

				if (existsSync(indexFile)) {
					inserts.push(`import { serveStatic } from 'hono/bun';
import { getRouter, registerDevModeRoutes } from '@agentuity/runtime';
import { readFileSync, existsSync } from 'node:fs';

(() => {
    const router = getRouter()!;
	
	// Setup workbench routes if workbench was bundled
	const workbenchIndexPath = import.meta.dir + '/workbench/index.html';
	if (existsSync(workbenchIndexPath)) {
		let workbenchIndex = readFileSync(workbenchIndexPath, 'utf-8');
		
		// Always serve assets at /workbench/* regardless of HTML route
		const workbenchStatic = serveStatic({ root: import.meta.dir + '/workbench' });
		router.get('/workbench/*', workbenchStatic);
		
		// Use the workbench config determined at build time
		const route = ${JSON.stringify(workbenchConfig?.route || '/workbench')};

		// If using custom route, update HTML to point to absolute /workbench/ paths
		if (route !== '/workbench') {
			workbenchIndex = workbenchIndex.replace(new RegExp('src="\\\\.\\\\/workbench\\\\/', 'g'), 'src="/workbench/');
		}
		
		// Serve HTML at the configured route
		router.get(route, (c) => c.html(workbenchIndex));
	}
	
	let index = readFileSync(import.meta.dir + '/web/index.html', 'utf-8');
	if (${isDevMode}) {
		const end = index.lastIndexOf('</html>');
		const html = registerDevModeRoutes(router);
		if (end > 0) {
			index = index.substring(0,end) + html + index.substring(end);
		} else {
			index += html;
		}
	}
	const webstatic = serveStatic({ root: import.meta.dir + '/web' });
	// In dev mode, serve from source; in prod, serve from build output
	const publicRoot = ${isDevMode} ? ${JSON.stringify(join(srcDir, 'web', 'public'))} : import.meta.dir + '/web/public';
	const publicstatic = serveStatic({ root: publicRoot, rewriteRequestPath: (path) => path });
	router.get('/', (c) => c.html(index));
    router.get('/web/chunk/*', webstatic);
    router.get('/web/asset/*', webstatic);
	// Serve public assets at root (e.g., /favicon.ico) - must be last
	router.get('/*', async (c, next) => {
		const path = c.req.path;
		// Prevent directory traversal attacks
		if (path.includes('..') || path.includes('%2e%2e')) {
			return c.notFound();
		}
		// Only serve from public folder at root (skip /web/* routes and /)
		if (path !== '/' && !path.startsWith('/web/')) {
			try {
				// serveStatic calls next() internally if file not found
				return await publicstatic(c, next);
			} catch (err) {
				return next();
			}
		}
		return next();
	});
})();`);
				}

				// Build agentInfo from all discovered agents and track directories
				const agentDirs = new Set<string>();
				for (const [_identifier, md] of agentMetadata) {
					// md.get('filename') can be either absolute or relative to rootDir
					const filename = md.get('filename')!;
					const absolutePath = filename.startsWith('/') ? filename : join(rootDir, filename);

					// Track which directories have agents
					const dir = dirname(absolutePath);
					agentDirs.add(dir);

					// Convert to path relative to srcDir
					// e.g., /path/to/src/agent/my-agent.ts -> ./agent/my-agent
					const agentPath = absolutePath.replace(srcDir, '.').replace('.ts', '');

					const agentDetail: Record<string, string> = {
						name: md.get('name')!,
						id: md.get('id')!,
						path: agentPath,
						filename: absolutePath,
						description: md.get('description') ?? '',
						agentId: md.get('agentId')!,
					};
					agentInfo.push(agentDetail);
				}

				// Validate that all directories in src/agent have at least one agent
				const agentBaseDir = join(srcDir, 'agent');
				if (existsSync(agentBaseDir)) {
					const { readdirSync, statSync } = await import('node:fs');
					const subdirs = readdirSync(agentBaseDir).filter((name) => {
						const fullPath = join(agentBaseDir, name);
						return statSync(fullPath).isDirectory();
					});

					for (const subdir of subdirs) {
						const fullPath = join(agentBaseDir, subdir);
						// Check if this directory or any subdirectory contains agents
						const hasAgentInTree = Array.from(agentDirs).some((agentDir) =>
							agentDir.startsWith(fullPath)
						);
						if (!hasAgentInTree) {
							throw new Error(
								`Directory ${subdir} in src/agent must contain at least one agent (a file with a createAgent export)`
							);
						}
					}
				}

				// Only generate registry if there are agents
				// Note: We don't import the registry here because:
				// 1. Evals are already imported when agents are registered (see line 421-422)
				// 2. The registry is for type definitions only, not runtime execution
				// 3. Importing it causes bundler resolution issues since it's generated during build
				generateAgentRegistry(srcDir, agentInfo);

				// Generate lifecycle types if setup() is present in app.ts
				await setupLifecycleTypes(rootDir, outDir, srcDir, logger);

				// Parse routes from src/api directory
				const apiRoutesMetadata: BuildMetadata['routes'] = [];
				const routeInfoList: RouteInfo[] = [];
				const apiDir = join(srcDir, 'api');
				// Track subdirectory routes for auto-mounting
				const subRouteInserts: string[] = [];
				if (existsSync(apiDir)) {
					// Use recursive route discovery to find all route files in subdirectories
					const discoveredRoutes = discoverRouteFiles(apiDir);

					// Collect all API files: index.ts and discovered subdirectory routes
					const apiFiles: string[] = [];

					// Check for root index.ts
					const indexFile = join(apiDir, 'index.ts');
					if (existsSync(indexFile)) {
						apiFiles.push(indexFile);
					}

					// Add all discovered route files
					for (const route of discoveredRoutes) {
						apiFiles.push(route.filepath);

						// Generate auto-mount code for this subdirectory route
						subRouteInserts.push(`await (async() => {
						const { getRouter } = await import('@agentuity/runtime');
						const router = getRouter()!;
						const ${route.variableName} = (await import('${route.importPath}')).default;
						router.route('${route.mountPath}', ${route.variableName});
						})();`);
					}

					for (const apiFile of apiFiles) {
						// Quick check: skip files that don't contain createRouter or Hono
						// This avoids expensive AST parsing for utility files
						const fileContent = await Bun.file(apiFile).text();
						if (!fileContent.includes('createRouter') && !fileContent.includes('new Hono')) {
							logger.trace(`Skipping ${apiFile}: no createRouter or Hono found`);
							continue;
						}

						try {
							const routes = await parseRoute(rootDir, apiFile, projectId, deploymentId);

							// Extract schemas from agents for routes that use validators
							for (const route of routes) {
								// Check if route has custom schema overrides from validator({ input, output })
								const hasCustomInput = route.config?.inputSchemaVariable;
								const hasCustomOutput = route.config?.outputSchemaVariable;

								// If route uses agent.validator(), get schemas from the agent (unless overridden)
								if (
									route.config?.agentImportPath &&
									(!hasCustomInput || !hasCustomOutput)
								) {
									const agentImportPath = route.config.agentImportPath as string;
									// Match by import path: @agent/zod-test -> src/agent/zod-test/agent.ts
									// Normalize import path by removing leading '@' -> agent/zod-test
									const importPattern = agentImportPath.replace(/^@/, '');
									// Escape regex special characters for safe pattern matching
									const escapedPattern = importPattern.replace(
										/[.*+?^${}()|[\]\\]/g,
										'\\$&'
									);
									// Match as complete path segment to avoid false positives (e.g., "agent/hello" matching "agent/hello-world")
									const segmentPattern = new RegExp(`(^|/)${escapedPattern}(/|$)`);

									for (const [, agentMd] of agentMetadata) {
										const agentFilename = agentMd.get('filename');
										if (agentFilename && segmentPattern.test(agentFilename)) {
											// Use agent schemas unless overridden
											const inputSchemaCode = hasCustomInput
												? undefined
												: agentMd.get('inputSchemaCode');
											const outputSchemaCode = hasCustomOutput
												? undefined
												: agentMd.get('outputSchemaCode');

											if (inputSchemaCode || outputSchemaCode) {
												route.schema = {
													input: inputSchemaCode,
													output: outputSchemaCode,
												};
											}
											break;
										}
									}
								}

								// TODO: Extract inline schema code from custom validator({ input: z.string(), output: ... })
								// For now, custom schema overrides with inline code are not extracted (would require parsing the validator call's object expression)
							}

							apiRoutesMetadata.push(...routes);

							// Collect route info for RouteRegistry generation
							for (const route of routes) {
								routeInfoList.push({
									method: route.method.toUpperCase(),
									path: route.path,
									filename: route.filename,
									hasValidator: route.config?.hasValidator === true,
									routeType: route.type || 'api',
									agentVariable: route.config?.agentVariable as string | undefined,
									agentImportPath: route.config?.agentImportPath as string | undefined,
									inputSchemaVariable: route.config?.inputSchemaVariable as
										| string
										| undefined,
									outputSchemaVariable: route.config?.outputSchemaVariable as
										| string
										| undefined,
									stream:
										route.config?.stream !== undefined && route.config.stream !== null
											? Boolean(route.config.stream)
											: route.type === 'stream'
												? true
												: undefined,
								});
							}
						} catch (error) {
							// Skip files that don't have proper router setup despite containing createRouter/Hono
							// (e.g., files that import but don't use them, or have syntax errors)
							if (error instanceof Error) {
								if (
									error.message.includes('could not find default export') ||
									error.message.includes('could not find an proper createRouter')
								) {
									logger.trace(`Skipping ${apiFile}: ${error.message}`);
								} else {
									throw error;
								}
							} else {
								throw error;
							}
						}
					}
				}

				// Generate RouteRegistry for type-safe route access
				if (routeInfoList.length > 0) {
					logger.trace(`Generating RouteRegistry with ${routeInfoList.length} routes`);
					generateRouteRegistry(srcDir, routeInfoList);
				}

				// Auto-mount src/api/index.ts if it exists
				const apiIndexPath = join(srcDir, 'api', 'index.ts');
				if (existsSync(apiIndexPath)) {
					inserts.push(`await (async() => {
	const { getRouter } = await import('@agentuity/runtime');
	const router = getRouter()!;
	const api = require('./src/api/index').default;
	router.route('/api', api);
})();`);
				}

				// Auto-mount subdirectory routes (src/api/foo/route.ts -> /api/foo)
				for (const subRouteInsert of subRouteInserts) {
					inserts.push(subRouteInsert);
				}

				// Only create the workbench routes if workbench is actually configured
				if (workbenchConfig) {
					inserts.push(`await (async() => {
	const { createWorkbenchRouter, getRouter } = await import('@agentuity/runtime');
	const router = getRouter()!;
	const workbenchRouter = createWorkbenchRouter();
	router.route('/', workbenchRouter);
})();`);
				}

				const file = Bun.file(args.path);
				let contents = await file.text();
				// Use AST-based parsing to reliably find createApp statement end
				const insertPos = findCreateAppEndPosition(contents);

				// Add initialization call after all agent registrations
				const setupCall = `
// Initialize providers and run agent setup callbacks after all agents are registered
await (async() => {
    const { runAgentSetups, getThreadProvider, getSessionProvider, getAppState } = await import('@agentuity/runtime');

	const threadProvider = getThreadProvider();
    const sessionProvider = getSessionProvider();

	const state = getAppState();

    // Initialize providers first
    await threadProvider.initialize(state);
	await sessionProvider.initialize(state);
    
    // Then run agent setups
    await runAgentSetups(state);
})();`;

				if (insertPos > 0) {
					contents =
						contents.slice(0, insertPos) +
						'\n\n' +
						inserts.join('\n') +
						setupCall +
						contents.slice(insertPos);
				} else {
					// Fallback: append to end if AST parsing fails
					logger.warn('Could not find createApp in AST, appending code to end of file');
					contents += `\n${inserts.join('\n')}${setupCall}`;
				}

				// generate the build metadata
				metadata = {
					routes: apiRoutesMetadata,
					agents: [],
				};

				// Validate required metadata properties and build agent metadata
				for (const [, v] of agentMetadata) {
					if (!v.has('filename')) {
						throw new MetadataPropertyMissingError({
							name: 'filename',
							message: 'agent metadata is missing expected filename property',
						});
					}
					if (!v.has('id')) {
						throw new MetadataPropertyMissingError({
							name: 'id',
							message: 'agent metadata is missing expected id property',
						});
					}
					if (!v.has('version')) {
						throw new MetadataPropertyMissingError({
							name: 'version',
							message: 'agent metadata is missing expected version property',
						});
					}
					if (!v.has('name')) {
						throw new MetadataPropertyMissingError({
							name: 'name',
							message: 'agent metadata is missing expected name property',
						});
					}
					if (!v.has('agentId')) {
						throw new MetadataPropertyMissingError({
							name: 'agentId',
							message: 'agent metadata is missing expected agentId property',
						});
					}
					const agentData: BuildMetadata['agents'][number] = {
						filename: v.get('filename')!,
						id: v.get('id')!,
						agentId: v.get('agentId')!,
						version: v.get('version')!,
						name: v.get('name')!,
						description: v.get('description') ?? '',
						projectId,
					};

					// Extract schema codes if available
					const inputSchemaCode = v.get('inputSchemaCode');
					const outputSchemaCode = v.get('outputSchemaCode');
					if (inputSchemaCode || outputSchemaCode) {
						agentData.schema = {
							input: inputSchemaCode,
							output: outputSchemaCode,
						};
					}

					const evalsStr = v.get('evals');
					if (evalsStr) {
						logger.trace(
							`[plugin] Found evals string for agent ${agentData.name}, parsing...`
						);
						try {
							const parsedEvals = JSON.parse(evalsStr) as Array<
								Omit<
									NonNullable<BuildMetadata['agents'][number]['evals']>[number],
									'agentIdentifier' | 'projectId'
								>
							>;
							agentData.evals = parsedEvals.map((evalItem) => ({
								...evalItem,
								agentIdentifier: agentData.agentId,
								projectId,
							}));
							logger.trace(
								`[plugin] Successfully parsed ${agentData.evals?.length ?? 0} eval(s) for agent ${agentData.name}`
							);
						} catch (e) {
							logger.trace(
								`[plugin] Failed to parse evals for agent ${agentData.name}: ${e}`
							);
							console.warn(`Failed to parse evals for agent ${agentData.name}: ${e}`);
						}
					} else {
						logger.trace(`[plugin] No evals found for agent ${agentData.name}`);
					}

					metadata.agents!.push(agentData);
				}

				return {
					contents,
					loader: 'ts',
				};
			}
		);
	},
};

export default AgentuityBundler;
