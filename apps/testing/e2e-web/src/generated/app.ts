// @generated
// Auto-generated by Agentuity
// DO NOT EDIT - This file is regenerated on every build
// Build mode: development
import { 
  createRouter,
  createBaseMiddleware,
  createCorsMiddleware,
  createOtelMiddleware,
  createAgentMiddleware,
  getAppState,
  getAppConfig,
  register,
  createServices,
  runAgentSetups,
  getThreadProvider,
  getSessionProvider,
  setGlobalLogger,
  setGlobalTracer,
  setGlobalRouter,
  enableProcessExitProtection,
  hasWaitUntilPending,
} from '@agentuity/runtime';
import type { Context } from 'hono';
import { websocket } from 'hono/bun';
import { serveStatic } from 'hono/bun';
import { readFileSync, existsSync } from 'node:fs';
import { type LogLevel } from '@agentuity/core';
import { bootstrapRuntimeEnv } from '@agentuity/cli/runtime-bootstrap';

// Step 0: Bootstrap runtime environment (load profile-specific .env files)
// Only in development - production env vars are injected by platform
// This must happen BEFORE any imports that depend on environment variables
if (process.env.NODE_ENV !== 'production') {
	// Pass project directory (two levels up from src/generated/) so .env files are loaded correctly
	await bootstrapRuntimeEnv({ projectDir: import.meta.dir + '/../..' });
}

// Step 1: Initialize telemetry and services
const serverUrl = `http://127.0.0.1:${process.env.PORT || '3500'}`;
const otel = register({ processors: [], logLevel: (process.env.AGENTUITY_LOG_LEVEL || 'info') as LogLevel });

// Get app state and config for use below
const appState = getAppState();
const appConfig = getAppConfig();

createServices(otel.logger, appConfig, serverUrl);

// Make logger and tracer globally available for user's app.ts
setGlobalLogger(otel.logger);
setGlobalTracer(otel.tracer);

// Step 2: Create router and set as global
const app = createRouter();
setGlobalRouter(app);

// Step 3: Apply middleware in correct order (BEFORE mounting routes)
app.use('*', createBaseMiddleware({
	logger: otel.logger,
	tracer: otel.tracer,
	meter: otel.meter,
}));

app.use('/_agentuity/*', createCorsMiddleware());
app.use('/api/*', createCorsMiddleware());

// Critical: otelMiddleware creates session/thread/waitUntilHandler
app.use('/_agentuity/*', createOtelMiddleware());
app.use('/api/*', createOtelMiddleware());

// Critical: agentMiddleware sets up agent context
app.use('/api/*', createAgentMiddleware(''));

// Step 4: Import user's app.ts (runs createApp, gets state/config)
await import('../../app.js');

// Step 5: Initialize providers
const threadProvider = getThreadProvider();
const sessionProvider = getSessionProvider();

await threadProvider.initialize(appState);
await sessionProvider.initialize(appState);

// Step 6: Mount routes (AFTER middleware is applied)

// Asset proxy routes - Development mode only (proxies to Vite asset server)
if (process.env.NODE_ENV !== 'production') {
	const VITE_ASSET_PORT = parseInt(process.env.VITE_PORT || '5173', 10);

	const proxyToVite = async (c: Context) => {
		const viteUrl = `http://127.0.0.1:${VITE_ASSET_PORT}${c.req.path}`;
		const controller = new AbortController();
		const timeout = setTimeout(() => controller.abort(), 10000); // 10s timeout
		try {
			otel.logger.debug(`[Proxy] ${c.req.method} ${c.req.path} -> Vite:${VITE_ASSET_PORT}`);
			const res = await fetch(viteUrl, { signal: controller.signal });
			clearTimeout(timeout);
			otel.logger.debug(`[Proxy] ${c.req.path} -> ${res.status} (${res.headers.get('content-type')})`);
			return new Response(res.body, {
				status: res.status,
				headers: res.headers,
			});
		} catch (err) {
			clearTimeout(timeout);
			if (err instanceof Error && err.name === 'AbortError') {
				otel.logger.error(`Vite proxy timeout: ${c.req.path}`);
				return c.text('Vite asset server timeout', 504);
			}
			otel.logger.error(`Failed to proxy to Vite: ${c.req.path} - ${err instanceof Error ? err.message : String(err)}`);
			return c.text('Vite asset server error', 500);
		}
	};

	// Vite client scripts and HMR
	app.get('/@vite/*', proxyToVite);
	app.get('/@react-refresh', proxyToVite);

	// Source files for HMR
	app.get('/src/web/*', proxyToVite);
	app.get('/src/*', proxyToVite); // Catch-all for other source files

	// Workbench source files (in .agentuity/workbench-src/)
	app.get('/.agentuity/workbench-src/*', proxyToVite);

	// Node modules (Vite transforms these)
	app.get('/node_modules/*', proxyToVite);

	// Scoped packages (e.g., @agentuity/*, @types/*)
	app.get('/@*', proxyToVite);

	// File system access (for Vite's @fs protocol)
	app.get('/@fs/*', proxyToVite);

	// Module resolution (for Vite's @id protocol)  
	app.get('/@id/*', proxyToVite);

	// Any .js, .jsx, .ts, .tsx files (catch remaining modules)
	app.get('/*.js', proxyToVite);
	app.get('/*.jsx', proxyToVite);
	app.get('/*.ts', proxyToVite);
	app.get('/*.tsx', proxyToVite);
	app.get('/*.css', proxyToVite);
}

// Mount API routes
const { default: router_0 } = await import('../api/index.js');
app.route('/api', router_0);

// Web routes - Development mode (proxies to Vite for HMR)
	// Development mode: Proxy HTML from Vite to enable React Fast Refresh
	const VITE_ASSET_PORT = parseInt(process.env.VITE_PORT || '5173', 10);
	
	const devHtmlHandler = async (c: Context) => {
		const viteUrl = `http://127.0.0.1:${VITE_ASSET_PORT}/src/web/index.html`;

		try {
			otel.logger.debug('[Proxy] GET /src/web/index.html -> Vite:%d', VITE_ASSET_PORT);
			const res = await fetch(viteUrl, { signal: AbortSignal.timeout(10000) });

			// Get HTML text and transform relative paths to absolute
			const html = await res.text();
			const transformedHtml = html
				.replace(/src="\.\//g, 'src="/src/web/')
				.replace(/href="\.\//g, 'href="/src/web/');

			return new Response(transformedHtml, {
				status: res.status,
				headers: res.headers,
			});
		} catch (err) {
			otel.logger.error('Failed to proxy HTML to Vite: %s', err instanceof Error ? err.message : String(err));
			return c.text('Vite asset server error (HTML)', 500);
		}
	};
	
	app.get('/', devHtmlHandler);
	
	// 404 for unmatched API/system routes
	app.all('/_agentuity/*', (c: Context) => c.notFound());
	app.all('/api/*', (c: Context) => c.notFound());
	app.all('/workbench/*', (c: Context) => c.notFound());
	
	// SPA fallback - serve index.html for client-side routing
	app.get('*', (c: Context) => {
		const path = c.req.path;
		// If path has a file extension, return 404 (prevents serving HTML for missing assets)
		if (/\.[a-zA-Z0-9]+$/.test(path)) {
			return c.notFound();
		}
		return devHtmlHandler(c);
	});

// Step 7: Run agent setup to signal completion
await runAgentSetups(appState);

// Start Bun server
if (typeof Bun !== 'undefined') {
	// Enable process exit protection now that we're starting the server
	enableProcessExitProtection();
	
	const port = parseInt(process.env.PORT || '3500', 10);
	const server = Bun.serve({
		fetch: app.fetch,
		websocket,
		port,
		hostname: '127.0.0.1',
	});
	
	// Make server available globally for health checks
	(globalThis as any).__AGENTUITY_SERVER__ = server;
	
	otel.logger.info(`Server listening on http://127.0.0.1:${port}`);
	if (process.env.VITE_PORT) {
		otel.logger.debug(`Proxying Vite assets from port ${process.env.VITE_PORT}`);
	}
}

// FOUND AN ERROR IN THIS FILE?
// Please file an issue at https://github.com/agentuity/sdk/issues
// or if you know the fix please submit a PR!

